# # The Kindle HUD can fetch train and traffic information, and display it# on workday mornings.# # Ideally, I would have liked to be able to get an estimate for the car# journey time to work for each morning.  This is obviously a possible# thing to do, because Google maps and Waze can deliver it to your phone,# but I found no way for a Kindle to fetch this information.# # Instead, I found that the RAC can send a daily email with traffic alerts# for a certain journey. The Kindle logs onto my email, fetches and parses# the email to extract the alerts, then displays them along with an icon.# # A similar thing happens with the train alerts.  The train company can send# a daily train alert.# # The problem with both of these systems is that they are very local. I assume# that the RAC only provides alerts for the UK, and the train company only for# their particular train line. It would be nice to have a more general purpose# system.# # Lastly, I was able to set up a daily pollen forecast, which arrives by email.# That's parsed by HandlePollenReport()# import datetimeimport imaplibimport emailimport json
import os
from HTMLParser import HTMLParsertoday     = datetime.date.today()yesterday = today - datetime.timedelta(days=1)# create a subclass and override the handler methodsclass MyHTMLParser(HTMLParser):    def __init__(self):        HTMLParser.__init__(self)        self.foundTrafficUpdate = False        self.lines = []        self.gotIncidentType = True        self.incidentType = 'none'            def handle_starttag(self, tag, attrs):        if tag == "img":            for attr in attrs:                if attr[0] == 'alt':                    if self.gotIncidentType == False:                        self.lines.append(attr[1])                        self.gotIncidentType = True                def handle_data(self, data):        data = data.lstrip()        if self.foundTrafficUpdate == True:            if data.startswith("Unsubscribe"):                self.foundTrafficUpdate = False            else:                if len(data)>1:                    if not (data.startswith("(About") | data.startswith("Updated") | data.startswith("<")):                        #print data                        self.lines.append(data)                        self.gotIncidentType = False        else:            if data.startswith("Your traffic"):                self.foundTrafficUpdate = True            def GetTrafficInfo(self):        trafficInfo = []        for i in range(0,len(self.lines),3):            trafficInfo.append([self.lines[i+2], self.lines[i+0], self.lines[i+1]])        return trafficInfo     def TrafficFetch(email_date):    if email_date.date() == today:        return 1    else:        return 0        def TrafficTrash(email_date):    return not TrafficFetch(email_date)    def TrainsFetch(email_date):    if (email_date.date() == today) & (email_date.time().hour < 9):    #if (email_date.date().day == 8):        return 1    else:        return 0        def TrainsTrash(email_date):    return not TrainsFetch(email_date)    def PollenFetch(email_date):    if email_date.date() == yesterday:        return 1    else:        return 0        def PollenTrash(email_date):    if (email_date.date() != yesterday) & (email_date.date() != today):        return 1    else:        return 0        def FetchMail(M, MailToFetch, MailToTrash):    rv, data = M.search(None, "ALL")    if rv != 'OK':        print("No messages found!")        return ""    returnMessage = ""        for num in data[0].split():        rv, data = M.fetch(num, '(RFC822)')        if rv != 'OK':            print("ERROR getting message", num)            return ""        trashing = False                msg = email.message_from_string(data[0][1])        print('Message %s: %s' % (num, msg['Subject']))        for part in msg.walk():            print "Content type:", part.get_content_type()            if (part.get_content_type() == 'text/html') | (part.get_content_type() == 'text/plain'):                print "Is Text"                messageBody = part.get_payload(decode=1)                date_tuple = email.utils.parsedate_tz(msg['Date'])                if date_tuple:                    print "date tuple", datetime.datetime.fromtimestamp(email.utils.mktime_tz(date_tuple))                    email_date = datetime.datetime.fromtimestamp(email.utils.mktime_tz(date_tuple))                    print "got email_date"                    #print "Local Date:", local_date.strftime("%a, %d %b %Y %H:%M:%S")                    print "Email Date: ", email_date                    print "Today:     ", today                    if MailToFetch(email_date):                        print "Fetch this Message"                        returnMessage = messageBody                                            if MailToTrash(email_date):                        trashing = True                                    if (trashing):            print "Trashing"            #M.store(num,'+X-GM-LABELS', '\\Trash')            print "Done trashing"        print ""    return returnMessage  def HandleTrafficReport(reportHTML):    icon    = "NoProblems"    heading = "No Information"    report  = "There is currently no information about traffic."            try:        parser = MyHTMLParser()        parser.feed(reportHTML)        trafficInfo = parser.GetTrafficInfo()        parser.close()    except:        trafficInfo = [[icon, heading, report]]    if len(trafficInfo) == 0:        trafficInfo = [[icon, heading, report]]        return trafficInfo    def HandleTrainReport(trainReport):    print ("HandleTrainReport()")    try:        if trainReport.find("no disruption") > -1:            icon    = "NoProblems"            heading = "Trains good"            report  = "There is no disruption reported at this time affecting services between Stratford and Ingatestone."            #trainInfo = [ ["NoProblems", "Trains good", "There is no disruption reported at this time affecting services between Stratford and Ingatestone."] ]        else:            if trainReport.find("delayed") > -1:                icon = "Delayed"                heading = "Delayed"                           if trainReport.find("cancelled") > -1:                icon = "Cancelled"                heading = "Cancelled"                            if trainReport.find("cancelled or delayed") > -1:                icon = "CancelledOrDelayed"                heading = "Cancelled or Delayed"                            lines = trainReport.split('\n')            report = lines[4] + lines[5]    except:        icon    = "NoProblems"        heading = "No Information"        report  = "There is currently no information about trains."            trainInfo = [icon, heading, report]    return [trainInfo]    def HandlePollenReport(pollenReport):    print "pollenReport 2"    #print pollenReport        try:        lines = pollenReport.split("\n")        forecast = "-"                for line in lines:            #f = line.find("Forecast for Tomorrow:")            if line.find("Level Very High") > -1:                forecast = "VH"                            if line.find("Level High") > -1:                forecast = "H"                            if line.find("Level Moderate") > -1:                forecast = "M"                            if line.find("Level Low") > -1:                forecast = "L"                            #if (f > -1):            #    print line            #    forecast = line.split("Pollen level",1)[1]             #    print "{"+forecast+"}"    except:        print "Pollen Exception trapped in HandlePollenReport(", pollenReport, ")"        forecast = "-"            return forecast.rstrip()    
def CheckPollenCache():
    print "Checking pollen cache"
    if os.path.exists("pollen_cache.json"):
        print "Pollen cache exists"
        with open("pollen_cache.json", "r") as f:
            pollenCache = json.loads(f.read())
            pollenCache[0] = datetime.datetime.strptime(pollenCache[0],'%Y%m%d')
            if pollenCache[0].date() < today:
                print "Pollen cache is old"
                return ""
            else:
                print "Pollen cache is current:", pollenCache[1]
                return pollenCache[1]
    else:
        print "Pollen cache doesn't exist"
        return ""

def WritePollenCache(pollenLevel):
    pollenCache = [datetime.date.today().strftime('%Y%m%d'), pollenLevel]
    print "Writing pollen cache:", pollenLevel
    with open("pollen_cache.json", 'w') as f:
        f.write(json.dumps(pollenCache))
    def GetEmails(whichEmails):    trafficInfo = []    M = imaplib.IMAP4_SSL('your.imap.server.com')        trafficInfo = []    trainsInfo  = []    pollenInfo  = ""        try:        print "Logging In to email"        M.login('you@youraddress.com', 'your_password')        print("OK?")        rv, mailboxes = M.list()        if whichEmails.find("Traffic") > -1:            rv, data = M.select("Traffic")            if rv == 'OK':                print "\nProcessing Traffic..."                trafficReportHTML = FetchMail(M, TrafficFetch, TrafficTrash)                print "Handling"                trafficInfo   = HandleTrafficReport(trafficReportHTML)                print "trafficInfo:", trafficInfo        else:            trafficInfo = []        print "trafficInfo:", trafficInfo                if whichEmails.find("Trains") > -1:            rv, data = M.select("Trains")            if rv == 'OK':                print("\nProcessing Trains...")                trainsReport = FetchMail(M, TrainsFetch, TrainsTrash)                print "Handling"                trainsInfo   = HandleTrainReport(trainsReport)                print "trainsInfo:", trainsInfo        else:            trainsInfo = []                    print "trainsInfo:", trainsInfo                if whichEmails.find("Pollen") > -1:
            pollenInfo = CheckPollenCache()
            if pollenInfo == "":                rv, data = M.select("Pollen")                if rv == 'OK':                    print "\nFetching Pollen..."                    pollenReport = FetchMail(M, PollenFetch, PollenTrash)                    print "Handling"                    pollenInfo   = HandlePollenReport(pollenReport)                                    print "pollenInfo:", pollenInfo
                    WritePollenCache(pollenInfo)        else:            pollenInfo = ""    except:        print("Email EXCEPTION ")        trafficInfo = []        trainsInfo  = []        pollenInfo  = ""                M.close()    print "Logging out"    M.logout()    print "Done"        return [trafficInfo, trainsInfo, pollenInfo]    